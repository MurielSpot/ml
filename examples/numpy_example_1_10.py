# 每个example可以单独运行。

# example 1-10
# 1：查看版本，配置；创建数组；数组大小，数组形状。
# 2：创建数组的函数：np.arange(0,1,0.1),np.linspace(0, 1, 3),np.logspace(0, 2, 20),np.fromstring(s, dtype=np.int8)。
# 3：存取元素。
# 4：多维数组。
# 5：

# example 1 #############################################################
import numpy as np

# 查看numpy版本和配置信息
np.__version__  
np.__config__.show()

# 创建数组
# 我们可以通过给array函数传递Python的序列对象创建数组，如果传递的是多层嵌套的序列，将创建多维数组(下例中的变量c):
a = np.array([1, 2, 3, 4])
b = np.array((5, 6, 7, 8))
c = np.array([[1, 2, 3, 4],[4, 5, 6, 7], [7, 8, 9, 10]])
print(a)
print(b)
print(c)
print(c.dtype)

# 数组的大小
print(a.shape)
print(c.shape)

# 改变数组形状
c.shape=4,3
print(c)

# 当某个轴的元素为-1时，将根据数组元素的个数自动计算此轴的长度.
c.shape=2,-1
print(c)

# reshape方法，可以创建一个改变了尺寸的新数组，原数组的shape保持不变：
d=c.reshape((-1,2))
print(d)

# 但reshape之后，数组c和d其实共享数据存储内存区域，因此修改其中任意一个数组的元素都会同时修改另外一个数组的内容：
c[1][3]=100
print(c)
print(d)

# 可以通过dtype参数在创建时指定元素类型:
print(np.array((2),dtype=np.float))

# example 2 #############################################################
import numpy as np

# 先创建一个Python序列，然后通过array函数将其转换为数组，这样做显然效率不高。
# 因此NumPy提供了很多专门用来创建数组的函数。

# arange函数类似于python的range函数，通过指定开始值、终值和步长来创建一维数组，注意数组不包括终值:
print(np.arange(0,1,0.1))

# linspace函数通过指定开始值、终值和元素个数来创建一维数组，可以通过endpoint关键字指定是否包括终值，缺省设置是包括终值:
print(np.linspace(0, 1, 3))

# logspace函数和linspace类似，不过它创建等比数列，下面的例子产生1(10^0)到100(10^2)、有20个元素的等比数列:
print(np.logspace(0, 2, 20))

# 使用frombuffer, fromstring, fromfile等函数可以从字节序列创建数组.

# Python的字符串实际上是字节序列，每个字符占一个字节，
# 因此如果从字符串s创建一个8bit的整数数组的话，所得到的数组正好就是字符串中每个字符的ASCII编码:
s = "abcdefgh"
print(np.fromstring(s, dtype=np.int8))

# 如果从字符串s创建16bit的整数数组，那么两个相邻的字节就表示一个整数，
# 把字节98和字节97当作一个16位的整数，它的值就是98*256+97 = 25185。
# 可以看出内存中是以little endian(低位字节在前)方式保存数据的。
print(np.fromstring(s, dtype=np.int16))

# 如果把整个字符串转换为一个64位的双精度浮点数数组，那么它的值是:
print("np.fromstring(s, dtype=np.float)")

# example 3 #############################################################
import numpy as np

a = np.array([1, 2, 3, 4])

# 存取元素 
# 数组元素的存取方法和Python的标准方法相同:
print("最初的a数组:",a)
print(a[3])
print(a[1:3])
print(a[:3])
# 下标可以使用负数，表示从数组后往前数
print("a[:-1]",a[:-1])
# 下标还可以用来修改元素的值
a[1:3]=-99,-98
print(a[:])
print("a[1:-1]",a[1:-1])
# 范围中的第三个参数表示步长，2表示隔一个元素取一个元素
print("a[1:-1:2]",a[1:-1:2])
# 省略范围的开始下标和结束下标，步长为-1，整个数组头尾颠倒
print("a[::-1]",a[::-1])
# 步长为负数时，开始下标必须大于结束下标
print("a[3:0:-1]",a[3:0:-1])

# 和Python的列表序列不同，通过下标范围获取的新的数组是原始数组的一个视图。它与原始数组共享同一块数据空间：
b=a[::-1]
print(a)
print(b)

b[2]=-111
print(a)
print(b)

# 除了使用下标范围存取元素之外，NumPy还提供了两种存取元素的高级方法：
# 使用整数序列 
# 当使用整数序列对数组元素进行存取时，将使用整数序列中的每个元素作为下标，整数序列可以是列表或者数组。使用整数序列作为下标获得的数组不和原始数组共享数据空间。
print("取下标为3,-1的元素：",a[[3,-1]])
b=a[[1,2]]
print("a[1,2]=b=",b)
b[0]=0
print("设置b[0]=0后，a:",a,"b:",b)

# 整数序列下标也可以用来修改元素的值
a[[1,2]]=0,0
print("a:",a)

# 使用布尔数组存取元素
# 当使用布尔数组b作为下标存取数组x中的元素时，将收集数组x中所有在数组b中对应下标为True的元素。使用布尔数组作为下标获得的数组不和原始数组共享数据空间，注意这种方式只对应于布尔数组，不能使用布尔列表。
# a有四个元素，所以np.array([True,False,True,False])中必须有四个true或false，不然会报错。
print(a[np.array([True,False,True,False])])

# 布尔数组一般不是手工产生，而是使用布尔运算的ufunc函数产生，关于ufunc函数请参照 ufunc运算 一节。
'''
x = np.random.rand(10) # 产生一个长度为10，元素值为0-1的随机数的数组
x
array([ 0.72223939,  0.921226  ,  0.7770805 ,  0.2055047 ,  0.17567449,
        0.95799412,  0.12015178,  0.7627083 ,  0.43260184,  0.91379859])
x>0.5
# 数组x中的每个元素和0.5进行大小比较，得到一个布尔数组，True表示x中对应的值大于0.5
array([ True,  True,  True, False, False,  True, False,  True, False,  True], dtype=bool)
x[x>0.5]
# 使用x>0.5返回的布尔数组收集x中的元素，因此得到的结果是x中所有大于0.5的元素的数组
array([ 0.72223939,  0.921226  ,  0.7770805 ,  0.95799412,  0.7627083 ,
        0.91379859])
'''

# example 4 #############################################################
import numpy as np

# 多维数组的存取
# 多维数组的存取和一维数组类似，因为多维数组有多个轴，因此它的下标需要用多个值来表示，NumPy采用组元(tuple)作为数组的下标。
# 组元不需要圆括号 
# 虽然我们经常在Python中用圆括号将组元括起来，但是其实组元的语法定义只需要用逗号隔开即可，例如 x,y=y,x 就是用组元交换变量值的一个例子。 
a=np.array([[0,1,2,3],[4,5,6,7]])
#去0行，2-3列的元素
print(a[0,2:4])

# 创建一个三维的数组
b=np.arange(0,27,1).reshape(-1,3,3)
print(b)

# example 5 #############################################################


# example 6 #############################################################
